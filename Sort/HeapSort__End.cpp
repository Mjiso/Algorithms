#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// heapSort 将待排序数组构建为大根堆（或小根堆），然后反复取出堆顶元素，最终得到有序序列。
/*
堆排序算法思想：
  1. 构建初始堆：将待排序的数组视为一个完全二叉树，并从最后一个叶子节点的父节点开始，依次向前构建堆。
      这个过程称为堆构建或堆化（heapify）。
  2. 堆化操作：在堆构建的过程中，对每个节点进行堆化操作，确保满足堆的性质（大根堆或小根堆）。
      堆化操作的目标是将当前节点与其子节点进行比较，并根据堆的性质进行交换，使得父节点的值大于或等于子节点（大根堆）或小于或等于子节点（小根堆）。
      这一步骤通常是递归完成的，确保堆的性质从根节点向下传递到整个堆。
  
  3. 堆排序：一旦初始堆构建完成，根节点（堆顶元素）是堆中最大（大根堆）或最小（小根堆）的元素。
      将根节点与堆的最后一个元素交换，将最大或最小元素移到排序的最终位置。
      然后，将堆的大小减一，并对新的根节点进行堆化，以确保堆的性质仍然得到维护。
      重复这个过程，直到堆中的所有元素都排好序。
  4. 重复步骤3：重复将堆的根节点与最后一个元素交换，并对堆进行堆化的步骤，直到整个数组都排序完成。

堆排序的核心思想是：先将原数组转化为一个二叉堆。然后不断地将堆顶元素取出，并将剩余元素重新构建为二叉堆，以实现排序。
*/
void heapify(vector<int>& nums, int length, int cur) {
    int large = cur;            // 初始化当前根节点的值最大（保存的是节点的下标）
    int left = 2*cur + 1;       // 当前根节点cur的左子节点（因为是从下标0开始保存的，所以要加一）
    int right = 2*cur + 2;      // 当前根节点cur的右子节点

    // 以下if语句的目的：从当前节点cur、左子节点left、右子节点right。这三个节点中找出值最大的，然后放到cur的这个位置。
    // 即：保证当前根节点的值是最大的。
    if(left < length && nums[left] > nums[large])    // 表示：left在有效范围内 && 左子节点值 > 右子节点值
        large = left;                                   // 更新最大值的下标
    if(right < length && nums[right] > nums[large])
        large = right;
    if(large != cur){                   // 若large不是原来的cur这个位置了，说明原来的cur这个位置的值不是最大的，需要交换
        swap(nums[large], nums[cur]);   // large下标和cur交换了值，以large为根节点的子树可能顺序被打破。所以下面要对large所在的子树继续堆化
        heapify(nums, length, large);           // 只是对large所在的子树进行堆化
    }
}

void buildHeap(vector<int>& nums) {
    int length = nums.size();
    for(int i = length / 2 - 1; i >= 0; i--) {  // 这里采用的是自下而上的堆化。即：从最后一个叶子节点的父节点开始堆化。
        heapify(nums, length, i);
    }
}

void heapSort(vector<int>& nums) {
    int length = nums.size();           // 第一步：构建初始最大堆
    buildHeap(nums);

    for(int i = length-1; i > -1; i--) {
        swap(nums[0], nums[i]);         // 第二步：将当前根节点（最大元素）与堆的最后一个元素交换位置
        heapify(nums, i, 0);            // 第三步：在剩余的堆上执行堆化操作以维护最大堆性质
    }
}

/*
复杂度分析：
    时间复杂度：O(n*log(n))。
      构建初始最大堆（buildHeap函数）： 
          在构建初始最大堆时，代码中使用了一个自底向上的堆化过程，对于包含n个元素的堆，时间复杂度是O(n)。
          因此，构建初始最大堆的时间复杂度为O(n)。
      堆排序（heapSort函数）： 在堆排序中，我们进行了n次循环，每次循环都会执行以下操作：
          交换堆顶元素与最后一个元素：这是O(1)的操作。
          对剩余堆进行堆化操作：堆化操作的时间复杂度是O(log n)，因为堆的高度是log n。
      因此，在堆排序中，总体时间复杂度是O(n*log n)， 可以看出堆排序在大规模数据排序时非常高效。
      
    空间复杂度：O(1)
      函数调用过程中会使用一些额外的栈空间，这个栈空间的深度取决于递归或迭代的调用深度。
      在这里，heapify函数的递归调用深度最多为堆的高度，即log n。因此，函数调用栈的空间复杂度为O(log n)。
      即：每个递归调用都会创建一个新的函数调用栈帧，每次递归调用都将数组分成两半，递归树的高度是对数级别的。
    
      但通常我们会将函数调用栈的空间复杂度忽略，因此通常将堆排序的空间复杂度视为O(1)。
  
稳定性：
  不稳定。因为在堆化的过程中，元素的相对位置可能发生变化。例如，对于具有相同关键字值的元素，它们在排序后可能会改变相对顺序。
*/
/******************************测试程序如下*******************************/
int main() {
    vector<int> nums = {5,9,8,0,7,1,6};
    buildHeap(nums);

    for_each(begin(nums), end(nums), [](int a){cout << a << " ";});
    cout << endl;

    heapSort(nums);

    for_each(begin(nums), end(nums), [](int a){cout << a << " ";});
    cout << endl;
    
    return 0;
}
/*
原来数组为：（假设原来的数组就是一个二叉堆，但是是无序的）
      5
    9   8
  0  7 1  6
  
第一次输出结果为：
  9 7 8 0 5 1 6 
即为：
      9
    7   8
  0  5 1  6
  每个节点的值都 > 其左子节点和右子节点。大根堆建立成功！
  
第二次输出结果为：0 1 5 6 7 8 9 可以看到已经按照从小到大进行排序！

从以上可以看出，如果是要按照从小到大进行排序的话，初始化堆应该是大根堆。
                因为最后堆排序时，每次将大根堆的根节点放到最后，然后堆化，重复该操作，直至原大根堆只剩一个元素，说明已经有序了！ 
*/