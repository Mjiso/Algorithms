#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// countSort 利用临时数组tmp记录每个元素出现的次数，通过累加次数来确定元素在排序后的位置
/*
计数排序算法思路;
  首先找出待排序数组中的最大值和最小值。
  然后创建一个临时数组tmp，其长度为最大值与最小值之差加1。
  接着遍历待排序数组，将每个元素值为索引，将tmp数组对应位置的值加1，表示该元素出现的次数。
  （例：temp[10] = 2, 表示元素 10 一共出现了 2 次，这个是基本思想。但是下面的代码用了偏移量进行优化。）
  最后再遍历tmp数组，根据tmp数组中每个元素的值，将对应的元素填充回原数组中，即完成排序。
*/
void countSort(vector<int>& nums) {
    int length = nums.size();
    int max = *max_element(begin(nums), end(nums)); // 找到数组中的最大值
    int min = *min_element(begin(nums), end(nums)); // 找到数组中的最小值
    vector<int> tmp(max-min+1, 0);                  // 计数数组。这里用了[0, max-min+1] 代替 [0, max-1]进行了空间优化

    for(int i = 0; i < length; i++) {               // 遍历原数组。元素值作为下标， 然后进行计数
        tmp[nums[i]-min]++;                         // 这里适用了偏移量min, 因为节省数组空间的原因
    }
    for(int i = 0, j = 0; i < length;) {
        while(tmp[j]--) nums[i++] = j+min;          // 因为上面计数时，使用了偏移量，所以这里回填的时候也要加上偏移量
        j++;
    }
}
/*
复杂度分析：
    时间复杂度：O(n+k)
      其中n为待排序数组的长度，k为最大值与最小值之差
    空间复杂度：O(k)
      其中k为：最大值与最小值之差加1
    
稳定性：
  稳定。因为在将计数数组对应的下标值，填充回原数组的过程中，相同元素的顺序不会改变。
*/

/*
计数排序适用场景：
  1. 整数排序：计数排序只能用于整数排序，因为它依赖于整数的特性来创建计数数组。
  2. 有限范围内的数据：计数排序适用于数据范围不太大的情况，
    因为它的性能与数据范围有关。如果数据范围非常大，计数数组的大小会增加，可能会消耗大量内存。
  3. 数据分布均匀：计数排序在数据分布相对均匀的情况下效果最好。
    如果数据分布不均匀，计数数组可能会浪费大量的空间。
  4. 不适用于负数：计数排序通常不适用于包含负数的数据集，因为它要求非负整数作为输入

总结：
  计数排序适用于特定类型的数据集，特别是整数排序范围较小且数据分布相对均匀的情况下
*/
/******************************测试程序如下*******************************/
int main() {
    vector<int> tmp = {9, 3, 6, 1, 8, 5, 2, 7, 4};
    for_each(begin(tmp), end(tmp), [](int a) { cout << a << " "; });
    cout << endl;

    countSort(tmp);
    for_each(begin(tmp), end(tmp), [](int a) { cout << a << " "; });
    cout << endl;
    return 0;
}